---
title: Реализация класса Вектор
summary: В данной проектной работе я расскажу как я написала класс Вектор на языке С++
tags:
  - Программирование
date: '2022-04-27T00:00:00Z'

# Optional external URL for project (replaces project detail page).
external_link: ''

image:
  caption: На фото мой макбук за 1000000$
  focal_point: Smart

# Slides (optional).
#   Associate this project with Markdown slides.
#   Simply enter your slide deck's filename without extension.
#   E.g. `slides = "example-slides"` references `content/slides/example-slides.md`.
#   Otherwise, set `slides = ""`.
---

- Что нужно знать для реализации?

1. Указатели
2. Move семантика (Дополнительный этап)
3. rValue и lValue ссылки (Дополнительный этап)
4. Шаблоны
5. Итераторы (Дополнительный этап)
6. Переопределение операторов

- Введение

Я буду использовать c++20. Также эта статья разбита на этапы:
Первый и второй этапы обязательны. Данный гайд предназначен для новичков

- Первый этап

Для начала нужно создать шаблонный класс. Для этого используется template. Далее определяем какие поля будет содержать класс: 

1. Указатель на область памяти, где будет находиться массив.
2. Размер вектора (size)
3. Максимальный размер вектора (capacity)

С первым и вторым пунктом всё понятно. А для чего нужен третий? Отвечая на этот вопрос, нужно вспомнить, что вектор - это динамический массив. Поэтому, чтобы каждый раз, при добавлении элемента, не выделять новую память, нужно выделить её с запасом. Также надо добавить конструктор класса.

- Второй этап

Теперь нужно добавить эти методы:
1) Метод, который проверяет пустой ли список: [[nodiscard]] bool isEmpty() const {
		return size_ == 0;
}
2) Метод получения размера вектора:
[[nodiscard]] size_t size() const {
		return size_;
}
3) Метод получения максимального размера вектора:
[[nodiscard]] size_t capacity() const {
		return capacity_;
}
4) Метод выделения новой памяти. Мы будем создавать новый массив arr_ с размером capacity * 2, чтобы выделять память с запасом. Но перед этим надо записать предыдущий массив arr_ в другой указатель tmp. Затем заполняем свободные ячейки массива arr_ ячейками tmp. Не забываем удалить указатель tmp, чтобы не было утечки памяти.
void addMemory() {
		capacity_ *= 2;
    T* tmp = arr_;
    arr_ = new T[capacity_];
    for (size_t i = 0; i < size_; ++i) arr_[i] = tmp[i];
    delete[] tmp;
}
5) Метод добавления элемента
Для начало нужно проверить - есть ли свободные ячейки. Если их нет вызываем addMemory(). Далее записываем элемент в индекс size_ и увеличиваем size_ на 1.
void pushBack(const T& value) {
		if (size_ >= capacity_) addMemory();
    arr_[size_++] = value;
}
6) Метод удаления элемента
Здесь нужно уточнить, что у этого метода будет один аргумент - индекс элемента, который нужно удалить.
Чтобы удалить элемент в начале или в середине, нужно переместить все элементы, которые правее данного, на 1 ячейку. А затем уменьшить size_ на 1. Если же этот элемент находиться в конце массива, мы просто уменьшаем size_ на 1.
void remove(size_t index) {
		for (size_t i = index + 1; i < size_; ++i) {
    		arr_[i - 1] = arr_[i];
    }
    --size_;
}
